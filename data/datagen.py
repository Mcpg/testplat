#!/usr/bin/env python3

#
# This script is responsible for generating game's .DAT files
#

import struct
from PIL import Image

#
# This is just the default VGA 256 color (actually a bit less) palette.
# I doubt changes will be needed, that's why the defaults are left.
#
# And yes, this table looks kind of ugly.
#
palette_data = [
(0x00, 0x00, 0x00), (0x00, 0x00, 0xAA), (0x00, 0xAA, 0x00), (0x00, 0xAA, 0xAA),
(0xAA, 0x00, 0x00), (0xAA, 0x00, 0xAA), (0xAA, 0x55, 0x00), (0xAA, 0xAA, 0xAA),
(0x55, 0x55, 0x55), (0x55, 0x55, 0xFF), (0x55, 0xFF, 0x55), (0x55, 0xFF, 0xFF),
(0xFF, 0x55, 0x55), (0xFF, 0x55, 0xFF), (0xFF, 0xFF, 0x55), (0xFF, 0xFF, 0xFF),
(0x00, 0x00, 0x00), (0x10, 0x10, 0x10), (0x20, 0x20, 0x20), (0x35, 0x35, 0x35),
(0x45, 0x45, 0x45), (0x55, 0x55, 0x55), (0x65, 0x65, 0x65), (0x75, 0x75, 0x75),
(0x8A, 0x8A, 0x8A), (0x9A, 0x9A, 0x9A), (0xAA, 0xAA, 0xAA), (0xBA, 0xBA, 0xBA),
(0xCA, 0xCA, 0xCA), (0xDF, 0xDF, 0xDF), (0xEF, 0xEF, 0xEF), (0xFF, 0xFF, 0xFF),
(0x00, 0x00, 0xFF), (0x41, 0x00, 0xFF), (0x82, 0x00, 0xFF), (0xBE, 0x00, 0xFF),
(0xFF, 0x00, 0xFF), (0xFF, 0x00, 0xBE), (0xFF, 0x00, 0x82), (0xFF, 0x00, 0x41),
(0xFF, 0x00, 0x00), (0xFF, 0x41, 0x00), (0xFF, 0x82, 0x00), (0xFF, 0xBE, 0x00),
(0xFF, 0xFF, 0x00), (0xBE, 0xFF, 0x00), (0x82, 0xFF, 0x00), (0x41, 0xFF, 0x00),
(0x00, 0xFF, 0x00), (0x00, 0xFF, 0x41), (0x00, 0xFF, 0x82), (0x00, 0xFF, 0xBE),
(0x00, 0xFF, 0xFF), (0x00, 0xBE, 0xFF), (0x00, 0x82, 0xFF), (0x00, 0x41, 0xFF),
(0x82, 0x82, 0xFF), (0x9E, 0x82, 0xFF), (0xBE, 0x82, 0xFF), (0xDF, 0x82, 0xFF),
(0xFF, 0x82, 0xFF), (0xFF, 0x82, 0xDF), (0xFF, 0x82, 0xBE), (0xFF, 0x82, 0x9E),
(0xFF, 0x82, 0x82), (0xFF, 0x9E, 0x82), (0xFF, 0xBE, 0x82), (0xFF, 0xDF, 0x82),
(0xFF, 0xFF, 0x82), (0xDF, 0xFF, 0x82), (0xBE, 0xFF, 0x82), (0x9E, 0xFF, 0x82),
(0x82, 0xFF, 0x82), (0x82, 0xFF, 0x9E), (0x82, 0xFF, 0xBE), (0x82, 0xFF, 0xDF),
(0x82, 0xFF, 0xFF), (0x82, 0xDF, 0xFF), (0x82, 0xBE, 0xFF), (0x82, 0x9E, 0xFF),
(0xBA, 0xBA, 0xFF), (0xCA, 0xBA, 0xFF), (0xDF, 0xBA, 0xFF), (0xEF, 0xBA, 0xFF),
(0xFF, 0xBA, 0xFF), (0xFF, 0xBA, 0xEF), (0xFF, 0xBA, 0xDF), (0xFF, 0xBA, 0xCA),
(0xFF, 0xBA, 0xBA), (0xFF, 0xCA, 0xBA), (0xFF, 0xDF, 0xBA), (0xFF, 0xEF, 0xBA),
(0xFF, 0xFF, 0xBA), (0xEF, 0xFF, 0xBA), (0xDF, 0xFF, 0xBA), (0xCA, 0xFF, 0xBA),
(0xBA, 0xFF, 0xBA), (0xBA, 0xFF, 0xCA), (0xBA, 0xFF, 0xDF), (0xBA, 0xFF, 0xEF),
(0xBA, 0xFF, 0xFF), (0xBA, 0xEF, 0xFF), (0xBA, 0xDF, 0xFF), (0xBA, 0xCA, 0xFF),
(0x00, 0x00, 0x71), (0x1C, 0x00, 0x71), (0x39, 0x00, 0x71), (0x55, 0x00, 0x71),
(0x71, 0x00, 0x71), (0x71, 0x00, 0x55), (0x71, 0x00, 0x39), (0x71, 0x00, 0x1C),
(0x71, 0x00, 0x00), (0x71, 0x1C, 0x00), (0x71, 0x39, 0x00), (0x71, 0x55, 0x00),
(0x71, 0x71, 0x00), (0x55, 0x71, 0x00), (0x39, 0x71, 0x00), (0x1C, 0x71, 0x00),
(0x00, 0x71, 0x00), (0x00, 0x71, 0x1C), (0x00, 0x71, 0x39), (0x00, 0x71, 0x55),
(0x00, 0x71, 0x71), (0x00, 0x55, 0x71), (0x00, 0x39, 0x71), (0x00, 0x1C, 0x71),
(0x39, 0x39, 0x71), (0x45, 0x39, 0x71), (0x55, 0x39, 0x71), (0x61, 0x39, 0x71),
(0x71, 0x39, 0x71), (0x71, 0x39, 0x61), (0x71, 0x39, 0x55), (0x71, 0x39, 0x45),
(0x71, 0x39, 0x39), (0x71, 0x45, 0x39), (0x71, 0x55, 0x39), (0x71, 0x61, 0x39),
(0x71, 0x71, 0x39), (0x61, 0x71, 0x39), (0x55, 0x71, 0x39), (0x45, 0x71, 0x39),
(0x39, 0x71, 0x39), (0x39, 0x71, 0x45), (0x39, 0x71, 0x55), (0x39, 0x71, 0x61),
(0x39, 0x71, 0x71), (0x39, 0x61, 0x71), (0x39, 0x55, 0x71), (0x39, 0x45, 0x71),
(0x51, 0x51, 0x71), (0x59, 0x51, 0x71), (0x61, 0x51, 0x71), (0x69, 0x51, 0x71),
(0x71, 0x51, 0x71), (0x71, 0x51, 0x69), (0x71, 0x51, 0x61), (0x71, 0x51, 0x59),
(0x71, 0x51, 0x51), (0x71, 0x59, 0x51), (0x71, 0x61, 0x51), (0x71, 0x69, 0x51),
(0x71, 0x71, 0x51), (0x69, 0x71, 0x51), (0x61, 0x71, 0x51), (0x59, 0x71, 0x51),
(0x51, 0x71, 0x51), (0x51, 0x71, 0x59), (0x51, 0x71, 0x61), (0x51, 0x71, 0x69),
(0x51, 0x71, 0x71), (0x51, 0x69, 0x71), (0x51, 0x61, 0x71), (0x51, 0x59, 0x71),
(0x00, 0x00, 0x41), (0x10, 0x00, 0x41), (0x20, 0x00, 0x41), (0x31, 0x00, 0x41),
(0x41, 0x00, 0x41), (0x41, 0x00, 0x31), (0x41, 0x00, 0x20), (0x41, 0x00, 0x10),
(0x41, 0x00, 0x00), (0x41, 0x10, 0x00), (0x41, 0x20, 0x00), (0x41, 0x31, 0x00),
(0x41, 0x41, 0x00), (0x31, 0x41, 0x00), (0x20, 0x41, 0x00), (0x10, 0x41, 0x00),
(0x00, 0x41, 0x00), (0x00, 0x41, 0x10), (0x00, 0x41, 0x20), (0x00, 0x41, 0x31),
(0x00, 0x41, 0x41), (0x00, 0x31, 0x41), (0x00, 0x20, 0x41), (0x00, 0x10, 0x41),
(0x20, 0x20, 0x41), (0x28, 0x20, 0x41), (0x31, 0x20, 0x41), (0x39, 0x20, 0x41),
(0x41, 0x20, 0x41), (0x41, 0x20, 0x39), (0x41, 0x20, 0x31), (0x41, 0x20, 0x28),
(0x41, 0x20, 0x20), (0x41, 0x28, 0x20), (0x41, 0x31, 0x20), (0x41, 0x39, 0x20),
(0x41, 0x41, 0x20), (0x39, 0x41, 0x20), (0x31, 0x41, 0x20), (0x28, 0x41, 0x20),
(0x20, 0x41, 0x20), (0x20, 0x41, 0x28), (0x20, 0x41, 0x31), (0x20, 0x41, 0x39),
(0x20, 0x41, 0x41), (0x20, 0x39, 0x41), (0x20, 0x31, 0x41), (0x20, 0x28, 0x41),
(0x2D, 0x2D, 0x41), (0x31, 0x2D, 0x41), (0x35, 0x2D, 0x41), (0x3D, 0x2D, 0x41),
(0x41, 0x2D, 0x41), (0x41, 0x2D, 0x3D), (0x41, 0x2D, 0x35), (0x41, 0x2D, 0x31),
(0x41, 0x2D, 0x2D), (0x41, 0x31, 0x2D), (0x41, 0x35, 0x2D), (0x41, 0x3D, 0x2D),
(0x41, 0x41, 0x2D), (0x3D, 0x41, 0x2D), (0x35, 0x41, 0x2D), (0x31, 0x41, 0x2D),
(0x2D, 0x41, 0x2D), (0x2D, 0x41, 0x31), (0x2D, 0x41, 0x35), (0x2D, 0x41, 0x3D),
(0x2D, 0x41, 0x41), (0x2D, 0x3D, 0x41), (0x2D, 0x35, 0x41), (0x2D, 0x31, 0x41),
(0x00, 0x00, 0x00), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00),
(0x00, 0x00, 0x00), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00), (0x00, 0x00, 0x00)
]

sprites = {
    "plyidle0": "player/idle0.png"
}

def convert_sprite(path, name):
    result = bytearray()
    
    try:
        im = Image.open(path)
    except IOError:
        print("Couldn't open image ", path, ": IOError")
        quit(1)
        return False
    
    with im:
        result.append(im.width)
        result.append(im.height)
        result += name.encode("ascii")
        
        for y in range(im.height):
            for x in range(im.width):
                pixel_rgba = im.getpixel((x, y))
                
                if pixel_rgba[3] == 0:
                    result.append(255) # Transparent pixel
                    continue
                
                pixel = (pixel_rgba[0], pixel_rgba[1], pixel_rgba[2])
                if not pixel in palette_data:
                    print(pixel)
                    print("Error: image ", path, " is not palette compliant!")
                    quit(1)
                    return False
                
                result.append(palette_data.index(pixel))
    
    return result

def generate_sprites_dat():
    try:
        file = open(str("../gamedir/SPRITES.DAT"), "wb")
    except IOError:
        print("IOError: could not open SPRITES.DAT!")
        quit(1)
    
    with file:
        file.write(struct.pack("<B", len(sprites)))
        
        for sprite in sprites:
            if len(sprite) != 8:
                print("Incorrect sprite name size for ", sprite, "!")
                quit(1)
            
            converted = convert_sprite(sprites[sprite], sprite)
            if not converted:
                print("Couldn't convert sprite ", sprite, "!")
                quit(1)
            
            file.write(converted)
            
def generate_anim_dat():
    pass

def generate_tileset_dat():
    pass

# ################################################

print("Generating SPRITES.DAT...")
generate_sprites_dat()

print("Generating ANIM.DAT...")
generate_anim_dat()

print("Generating TILESET.DAT...")
generate_tileset_dat()

print("Finished!")
